package main

import (
	"fmt"
	"log"
	"os"
	"time"

	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/fiber/v2/middleware/cors"
	jwtware "github.com/gofiber/jwt/v2"
	"github.com/gofiber/swagger"
	"github.com/gofiber/template/html/v2"
	"github.com/golang-jwt/jwt"
	"github.com/joho/godotenv"

	// docs are generated by Swag CLI, you have to import them.
	// replace with your own docs folder, usually "github.com/username/reponame/docs"
	_ "gofiber/docs"
)

// func main() {
//   http.HandleFunc("/hello", helloHandler)

//   fmt.Printf("Starting server at port 8080\n")
//   if err := http.ListenAndServe(":8080", nil); err != nil {
//     log.Fatal(err)
//   }
// }

// standard library ที่สามารถทำได้ในภาษา Go คือ net/http
//
//	ข้อเสียยุ่งยาก
// func helloHandler(w http.ResponseWriter, r *http.Request) {
// 	if r.URL.Path != "/hello" {
// 		http.Error(w, "404 not found.", http.StatusNotFound)
// 		return
// 	}

// 	if r.Method != "GET" {
// 		http.Error(w, "Method is not supported.", http.StatusNotFound)
// 		return
// 	}

// 	fmt.Fprintf(w, "Hello World!")
// }

// ====================================================================================

// Fiber คือ library ที่ได้แรงบันดาลใจมาจาก Express (ของฝั่ง node.js) ที่ build อยู่บน Fasthttp

// Fasthttp คือ fastest HTTP engine for Go
// เน้นไปที่ความไว และความสามารถในการจัดการ "zero memory allocation" ได้

// go get github.com/gofiber/fiber/v2

// HTTP Method ของ API กัน โดยปกติ Fiber ได้เตรียม method ไว้ให้ใช้ตามนี้

// // HTTP methods
// func (app *App) Get(path string, handlers ...Handler) Router
// func (app *App) Head(path string, handlers ...Handler) Router
// func (app *App) Post(path string, handlers ...Handler) Router
// func (app *App) Put(path string, handlers ...Handler) Router
// func (app *App) Delete(path string, handlers ...Handler) Router
// func (app *App) Connect(path string, handlers ...Handler) Router
// func (app *App) Options(path string, handlers ...Handler) Router
// func (app *App) Trace(path string, handlers ...Handler) Router
// func (app *App) Patch(path string, handlers ...Handler) Router

// // Add allows you to specifiy a method as value
// func (app *App) Add(method, path string, handlers ...Handler) Router

// // All will register the route on all HTTP methods
// // Almost the same as app.Use but not bound to prefixes
// func (app *App) All(path string, handlers ...Handler) Router

// @title Book API
// @description This is a sample server for a book API.
// @version 1.0
// @host localhost:8080
// @BasePath /
// @schemes http
// @securityDefinitions.apikey ApiKeyAuth
// @in header
// @name Authorization
func main() {

	// Load environment variables from .env file
	err := godotenv.Load()
	if err != nil {
		log.Fatal("Error loading .env file")
	}
	// Initialize standard Go html template engine
	engine := html.New("./views", ".html")

	// Pass the engine to Fiber
	app := fiber.New(fiber.Config{
		Views: engine,
	})

	app.Get("/swagger/*", swagger.HandlerDefault) // default

	app.Get("/swagger/*", swagger.New(swagger.Config{ // custom
		URL:         "http://example.com/doc.json",
		DeepLinking: false,
		// Expand ("list") or Collapse ("none") tag groups by default
		DocExpansion: "none",
		// Prefill OAuth ClientId on Authorize popup
		OAuth: &swagger.OAuthConfig{
			AppName:  "OAuth Provider",
			ClientId: "21bb4edc-05a7-4afc-86f1-2e151e4ba6e2",
		},
		// Ability to change OAuth2 redirect uri location
		OAuth2RedirectUrl: "http://localhost:8080/swagger/oauth2-redirect.html",
	}))

	// Setup route
	app.Get("/", renderTemplate)

	//app := fiber.New()

	// app.Get("/hello", func(c *fiber.Ctx) error {
	// 	return c.SendString("Hello World")
	// })

	// Apply CORS middleware
	app.Use(cors.New(cors.Config{
		AllowOrigins: "*", // Adjust this to be more restrictive if needed
		AllowMethods: "GET,POST,HEAD,PUT,DELETE,PATCH",
		AllowHeaders: "Origin, Content-Type, Accept",
	}))

	// Use the logging middleware
	app.Use(loggingMiddleware)

	// Setup routes
	app.Get("/book", GetBooks)
	app.Get("/book/:id", GetBook)
	app.Post("/book", CreateBook)
	app.Put("/book/:id", UpdateBook)
	app.Delete("/book/:id", DeleteBook)
	// Setup route
	app.Post("/upload", UploadImage)

	// Setup routes
	app.Get("/api/config", getConfig)

	// JWT Secret Key
	secretKey := "secret"
	// Login route
	app.Post("/login", login(secretKey))
	// Login route
	app.Post("/loginV2", loginV2(secretKey))

	// JWT Middleware
	app.Use(jwtware.New(jwtware.Config{
		SigningKey: []byte(secretKey),
	}))

	// Middleware to extract user data from JWT
	app.Use(extractUserFromJWT)

	// Use the environment variable for the port
	port := os.Getenv("PORT")
	if port == "" {
		port = "8080" // Default port if not specified
	}

	app.Listen(":" + port)
}

// ====================== Template
func renderTemplate(c *fiber.Ctx) error {
	// Render the template with variable data
	return c.Render("template", fiber.Map{
		"Name": "World",
	})
}

// ========================    ENV
func getConfig(c *fiber.Ctx) error {
	// Example: Return a configuration value from environment variable
	secretKey := os.Getenv("SECRET_KEY")
	if secretKey == "" {
		secretKey = "defaultSecret" // Default value if not specified
	}

	return c.JSON(fiber.Map{
		"secret_key": secretKey,
	})
}

// ========================= Middleware Logs
// loggingMiddleware logs the processing time for each request
func loggingMiddleware(c *fiber.Ctx) error {
	// Start timer
	start := time.Now()

	// Process request
	err := c.Next()

	// Calculate processing time
	duration := time.Since(start)

	// Log the information
	fmt.Printf("Request URL: %s - Method: %s - Duration: %s\n", c.OriginalURL(), c.Method(), duration)

	return err
}

// ============Middleware และการ login
// go get -u github.com/gofiber/jwt/v2
// Dummy user for example
func main_V1() {
	app := fiber.New()

	// JWT Secret Key
	secretKey := "secret"

	// Login route
	app.Post("/login", login(secretKey))

	// JWT Middleware
	app.Use(jwtware.New(jwtware.Config{
		SigningKey: []byte(secretKey),
	}))

	// Protected Book routes
	app.Get("/book", GetBooks)
	app.Get("/book/:id", GetBook)
	app.Post("/book", CreateBook)
	app.Put("/book/:id", UpdateBook)
	app.Delete("/book/:id", DeleteBook)

	app.Listen(":8080")
}

var user = struct {
	Email    string
	Password string
}{
	Email:    "user@example.com",
	Password: "password123",
}

func login(secretKey string) fiber.Handler {
	return func(c *fiber.Ctx) error {
		type LoginRequest struct {
			Email    string `json:"email"`
			Password string `json:"password"`
		}

		var request LoginRequest
		if err := c.BodyParser(&request); err != nil {
			return err
		}

		// Check credentials - In real world, you should check against a database
		if request.Email != user.Email || request.Password != user.Password {
			return fiber.ErrUnauthorized
		}

		// Create token
		token := jwt.New(jwt.SigningMethodHS256)

		// Set claims
		claims := token.Claims.(jwt.MapClaims)
		claims["name"] = "John Doe"
		claims["admin"] = true
		claims["exp"] = time.Now().Add(time.Hour * 72).Unix()

		// Generate encoded token
		t, err := token.SignedString([]byte(secretKey))
		if err != nil {
			return c.SendStatus(fiber.StatusInternalServerError)
		}

		return c.JSON(fiber.Map{"token": t})
	}
}

// ===================Middleware กับการดึงค่าส่งต่อมา
func loginV2(secretKey string) fiber.Handler {
	return func(c *fiber.Ctx) error {
		type LoginRequest struct {
			Email    string `json:"email"`
			Password string `json:"password"`
		}

		var request LoginRequest
		if err := c.BodyParser(&request); err != nil {
			return err
		}

		// Check credentials - In real world, you should check against a database
		if request.Email != user.Email || request.Password != user.Password {
			return fiber.ErrUnauthorized
		}

		// Create token
		token := jwt.New(jwt.SigningMethodHS256)

		// Set claims
		claims := token.Claims.(jwt.MapClaims)
		claims["email"] = user.Email
		claims["role"] = "admin" // example role
		claims["exp"] = time.Now().Add(time.Hour * 72).Unix()

		// Generate encoded token
		t, err := token.SignedString([]byte(secretKey))
		if err != nil {
			return c.SendStatus(fiber.StatusInternalServerError)
		}

		return c.JSON(fiber.Map{"token": t})
	}
}

// UserData represents the user data extracted from the JWT token
type UserData struct {
	Email string
	Role  string
}

// userContextKey is the key used to store user data in the Fiber context
const userContextKey = "user"

// extractUserFromJWT is a middleware that extracts user data from the JWT token
func extractUserFromJWT(c *fiber.Ctx) error {
	user := &UserData{}

	// Extract the token from the Fiber context (inserted by the JWT middleware)
	token := c.Locals("user").(*jwt.Token)
	claims := token.Claims.(jwt.MapClaims)

	fmt.Println(claims)

	user.Email = claims["email"].(string)
	user.Role = claims["role"].(string)

	// Store the user data in the Fiber context
	c.Locals(userContextKey, user)

	return c.Next()
}

// ที่ book.go (ที่เรียก router แต่เดิม)
// ยกตัวอย่างกับ getBooks
func getBooks(c *fiber.Ctx) error {
	// Retrieve user data from the context
	user := c.Locals(userContextKey).(*UserData)

	// Use the user data (e.g., for authorization, custom responses, etc.)
	fmt.Printf("User Email: %s, Role: %s\n", user.Email, user.Role)

	return c.JSON(books)
}

// ========================== Middleware กับการกั้นสิทธิบาง API
// ทำการแยกกลุ่มการตรวจสอบโดยจะทำเพียงแค่บาง API เท่านั้น = ใช้ concept group API ของ fiber ได้
// https://docs.gofiber.io/guide/grouping
// isAdmin checks if the user is an admin
// isAdmin checks if the user is an admin
func isAdmin(c *fiber.Ctx) error {
	user := c.Locals(userContextKey).(*UserData)

	if user.Role != "admin" {
		return fiber.ErrUnauthorized
	}

	return c.Next()
}

func main_V3() {
	app := fiber.New()

	// JWT Secret Key
	secretKey := "secret"

	// Login route
	app.Post("/login", login(secretKey))

	// JWT Middleware
	app.Use(jwtware.New(jwtware.Config{
		SigningKey: []byte(secretKey),
	}))

	// Middleware to extract user data from JWT
	app.Use(extractUserFromJWT)

	// Group routes under /book
	bookGroup := app.Group("/book")

	// Apply the isAdmin middleware only to the /book routes
	bookGroup.Use(isAdmin)

	// Now, only authenticated admins can access these routes
	bookGroup.Get("/", getBooks)
	bookGroup.Get("/:id", GetBook)
	bookGroup.Post("/", CreateBook)
	bookGroup.Put("/:id", UpdateBook)
	bookGroup.Delete("/:id", DeleteBook)

	app.Listen(":8080")
}
