# Concurrent คืออะไร ?
การเขียนโปรแกรมที่ทำให้โปรแกรมสามารถทำงานหลาย ๆ อย่างพร้อมกันได้ โดยใช้หน่วยประมวลผล (CPU) ร่วมกัน

ใน Go นั้น มีวิธีการเขียนโปรแกรมแบบ concurrent อยู่หลายวิธี

Goroutines = หน่วยของการทำงานแบบ concurrent ใน Go โดยแต่ละ Goroutine จะทำงานแบบอิสระต่อกัน และไม่รบกวนการทำงานของ Goroutine อื่น ๆ
Channels = ช่องทางที่ใช้สำหรับการสื่อสารระหว่าง Goroutines ด้วยกัน
Waitgroups = โครงสร้างข้อมูลที่ใช้สำหรับรอให้ Goroutines ทั้งหมดทำงานเสร็จสิ้น

การเขียนโปรแกรมแบบ concurrent นั้นจำเป็นต้องมีความเข้าใจเกี่ยวกับหลักการของ concurrency และ synchronization เพื่อหลีกเลี่ยงปัญหาที่อาจเกิดขึ้น

Deadlock = สถานการณ์ที่ Goroutines สองตัวหรือมากกว่านั้น ต่างก็รอให้ Goroutines อีกตัวหนึ่งทำงานเสร็จสิ้นก่อน จึงจะทำงานต่อได้ แต่ Goroutines ทั้งสองตัวหรือมากกว่านั้น ต่างก็รอให้ Goroutines อีกตัวหนึ่งทำงานเสร็จสิ้นก่อนเช่นกัน
Race condition = สถานการณ์ที่ Goroutines สองตัวหรือมากกว่านั้น พยายามเข้าถึงข้อมูลร่วมกันในเวลาเดียวกัน และการเปลี่ยนแปลงข้อมูลนั้นอาจทำให้ผลลัพธ์ที่ไม่คาดคิดเกิดขึ้นได้


# Channel คืออะไร
Channel ใน Go คือ ช่องทางที่ใช้สำหรับการสื่อสารระหว่าง Goroutines ด้วยกัน โดย Channel นั้นสามารถส่งข้อมูลได้ทั้งแบบ synchronous และแบบ asynchronous

Synchronous คือ โปรแกรมที่คำสั่งต่าง ๆ ทำงานตามลำดับ โดยคำสั่งหนึ่งจะทำงานต่อได้ก็ต่อเมื่อคำสั่งก่อนหน้าทำงานเสร็จสิ้นแล้ว
Asynchronous คือ โปรแกรมที่คำสั่งต่าง ๆ สามารถทำงานพร้อมกันได้ โดยคำสั่งหนึ่ง "ไม่จำเป็นต้องรอ" ให้คำสั่งก่อนหน้าทำงานเสร็จสิ้นก่อนจึงจะทำงานต่อได้
ซึ่ง Channel สามารถใช้งานได้ทั้ง 2 แบบ เปรียบเสมือนมีท่อหนึ่งที่ใช้สำหรับส่งข้อมูล ลองมาดูตัวอย่าง code ทั้ง 2 แบบ

Operator ที่ใช้จัดการ Channel

<- = Operator นี้ใช้สำหรับการส่งและรับข้อมูลระหว่าง Goroutines ด้วยกัน โดย
Goroutine ที่ส่งข้อมูลจะใช้ operator <- กับตัวแปร Channel โดยให้ข้อมูลที่ต้องการส่งเป็น argument แรก
ส่วน Goroutine ที่รับข้อมูลจะใช้ operator <- กับตัวแปร Channel โดยไม่มีการให้ argument ใด ๆ

# Channel สามารถใช้กับเหตุการณ์ต่าง ๆ ดังนี้

1 การแชร์ข้อมูลระหว่าง Goroutines = Channel สามารถใช้สำหรับแชร์ข้อมูลระหว่าง Goroutines ด้วยกัน โดย Goroutines ใด ๆ ก็ตามที่สามารถเข้าถึง Channel นั้น ๆ ก็สามารถส่งและรับข้อมูลได้
2 การ Synchonize การทำงานระหว่าง Goroutines = Channel สามารถใช้สำหรับ Synchonize การทำงานระหว่าง Goroutines ด้วยกัน โดย Goroutines ใด ๆ ก็ตามที่ต้องการรอให้ Goroutines อื่น ๆ ทำงานเสร็จสิ้นก่อน จึงจะทำงานต่อได้ สามารถใช้ Channel ในการรอคอย
3 การรอเหตุการณ์บางอย่าง = Channel สามารถใช้สำหรับรอเหตุการณ์บางอย่าง เช่น รอให้ผู้ใช้กดปุ่ม รอให้ข้อมูลพร้อมใช้งาน เป็นต้น

# buffer channel
Buffer channel ใน Go คือ Channel ที่มี Buffer อยู่ภายใน โดย Buffer ทำหน้าที่เก็บข้อมูลไว้ชั่วคราว ช่วยให้การส่งข้อมูลระหว่าง Goroutines เป็นไปอย่างราบรื่นยิ่งขึ้น

Buffer channel สามารถสร้างได้โดยใช้ฟังก์ชัน make() โดยให้ argument ที่สองเป็นจำนวน Buffer ที่ต้องการ

# Ext ===> ch := make(chan int, 10)

Channel ch จะมี Buffer ขนาด 10 ตัว

ประโยชน์ของ Buffer channel

ช่วยให้การส่งข้อมูลระหว่าง Goroutines เป็นไปอย่างราบรื่นยิ่งขึ้น โดย Goroutine ที่ส่งข้อมูลไม่จำเป็นต้องรอให้ Goroutine ที่รับข้อมูลว่างเปล่าก่อนจึงจะสามารถส่งข้อมูลได้
ช่วยลดปัญหา Deadlock โดย Goroutine ที่ส่งข้อมูลจะไม่ค้างหาก Buffer เต็ม
Limitation

หาก Buffer เต็ม Goroutine ที่ส่งข้อมูลจะค้างจนกว่าจะมีข้อมูลถูกรับออกไปจาก Buffer
หาก Buffer ว่าง Goroutine ที่รับข้อมูลจะค้างจนกว่าจะมีข้อมูลถูกส่งเข้ามาใน Buffer


# Select Statement

Select statement ของ channel ใน Go คือ statement ที่ใช้สำหรับการเลือกการทำงานระหว่าง Goroutines ด้วยกัน โดย Goroutine ที่ทำงานกับ Channel สามารถใช้ select statement เพื่อเลือกการทำงานระหว่างการส่งข้อมูลไปยัง Channel และการรอรับข้อมูลจาก Channel

select {
  case v := <-ch:
    // ทำงานเมื่อได้รับข้อมูลจาก Channel
  case ch <- v:
    // ทำงานเมื่อส่งข้อมูลไปยัง Channel
}

# Sync package คืออะไร
https://pkg.go.dev/sync


Sync package ในภาษา Go เป็น package มาตรฐานที่ให้บริการฟังก์ชันและโครงสร้างข้อมูลสำหรับการประสานงานระหว่าง goroutines ฟังก์ชันและโครงสร้างข้อมูลเหล่านี้ช่วยให้นักพัฒนาสามารถเขียนโปรแกรมที่มี goroutines จำนวนมากที่ทำงานร่วมกันได้อย่างมีประสิทธิภาพและหลีกเลี่ยงปัญหาที่อาจเกิดขึ้น เช่น deadlocks, race condition ได้

เพิ่มเติม

Race condition คือ ปัญหาที่อาจเกิดขึ้นเมื่อหลาย goroutine พยายามเข้าถึงและแก้ไขทรัพยากรหรือข้อมูลร่วมกันในเวลาเดียวกัน ปัญหานี้อาจทำให้ข้อมูลหรือผลลัพธ์ของโปรแกรมไม่ถูกต้องหรือคาดเดาไม่ได้
ฟังก์ชันและโครงสร้างข้อมูลที่สำคัญบางประการใน Sync package ได้แก่:

# Mutex ช่วยให้ goroutines สามารถเข้าถึงทรัพยากรร่วมกันได้อย่างปลอดภัย Mutex ทำงานโดยการล็อกทรัพยากรเมื่อ goroutine กำลังใช้งานอยู่ และปลดล็อกทรัพยากรเมื่อ goroutine เสร็จสิ้นการใช้งาน

var mu sync.Mutex
mu.Lock()
// critical section
mu.Unlock()


# Cond ช่วยให้ goroutines รอเงื่อนไขบางอย่างให้เป็นจริง Cond ทำงานโดยการล็อกทรัพยากรเมื่อ goroutine กำลังรอ และปลดล็อกทรัพยากรเมื่อเงื่อนไขเป็นจริง

var mu sync.Mutex
cond := sync.NewCond(&mu)
// goroutine waits on condition
cond.Wait()
// signal or broadcast to wake goroutine
cond.Signal() // or cond.Broadcast()

var rwmu sync.RWMutex
rwmu.RLock() // for reading
// read section
rwmu.RUnlock()

rwmu.Lock() // for writing
// write section
rwmu.Unlock()

# Once sync.Once เป็นการ synchronization แบบดั้งเดิม ที่ package sync จัดเตรียมไว้ เพื่อให้แน่ใจว่า code บางส่วนจะถูกเรียกใช้งานเพียง "ครั้งเดียว" โดยไม่คำนึงว่า goroutine จะ run code ไปแล้วกี่ครั้งก็ตาม

var once sync.Once
once.Do(func() {
  // initialization or setup code
})

# WaitGroup ช่วยให้ goroutines รอให้ goroutines อื่น ๆ ทำงานเสร็จสิ้น WaitGroup ทำงานโดยการนับจำนวน goroutines ที่ทำงานอยู่ เมื่อจำนวน goroutines เหลือศูนย์ ฟังก์ชัน Wait() จะหยุดการทำงาน

var wg sync.WaitGroup
wg.Add(1)
go func() {
    defer wg.Done()
    // do work
}()
wg.Wait()


# WaitGroup

WaitGroup เป็นโครงสร้างข้อมูลแบบ mutex-guarded counter ที่ช่วยให้ goroutines สามารถรอให้ goroutines อื่น ๆ ทำงานเสร็จสิ้น WaitGroup ทำงานโดยการนับจำนวน goroutines ที่ทำงานอยู่ เมื่อจำนวน goroutines เหลือศูนย์ ฟังก์ชัน Wait() จะหยุดการทำงาน

ประโยชน์

ช่วยให้ goroutines สามารถรอให้ goroutines อื่น ๆ ทำงานเสร็จสิ้นได้อย่างมีประสิทธิภาพ
ปรับปรุงประสิทธิภาพโดยหลีกเลี่ยงการวนซ้ำตรวจสอบสถานะของ goroutines อื่น ๆ อย่างต่อเนื่อง

ตัวอย่างการใช้งาน

การรอให้ goroutines ทั้งหมดทำงานเสร็จสิ้น เช่น การรวบรวมผลลัพธ์จาก goroutines หลายตัว
การประสานงานระหว่าง goroutines เช่น การรอให้ goroutine อื่นเริ่มต้นทำงาน

# Mutex
Mutex เป็นโครงสร้างข้อมูลแบบ mutex-guarded lock ที่ช่วยให้ goroutines สามารถเข้าถึงทรัพยากรร่วมกันได้อย่างปลอดภัย Mutex ทำงานโดยการล็อกทรัพยากรเมื่อ goroutine กำลังใช้งานอยู่ และปลดล็อกทรัพยากรเมื่อ goroutine เสร็จสิ้นการใช้งาน

ประโยชน์

ป้องกัน race conditions
ช่วยให้ goroutines ทำงานร่วมกันได้อย่างปลอดภัย ปรับปรุงประสิทธิภาพโดยหลีกเลี่ยงการเข้าถึงทรัพยากรร่วมกันโดยไม่จำเป็น
เริ่มจาก code เล็กๆกันก่อน

Note

mutex.Lock() เป็นคำสั่งสำหรับการ Lock resource และจะรอจนกว่าการปลดล็อค ( mutex.Unlock()) จะเกิดขึ้น


# Once
Once เป็นโครงสร้างข้อมูลแบบ mutex-guarded conditional variable ที่ช่วยให้ goroutines สามารถดำเนินการเฉพาะได้ครั้งเดียวเท่านั้น

ประโยชน์

ช่วยให้ goroutines สามารถดำเนินการเฉพาะได้ครั้งเดียวเท่านั้น
ป้องกัน race conditions จากคำสั่งที่ต้องทำเพียงแค่ครั้งเดียวในระบบ

# Cond
Cond เป็นโครงสร้างข้อมูลแบบ mutex-guarded condition variable ที่ช่วยให้ goroutines สามารถรอเงื่อนไขบางอย่างให้เป็นจริง Cond ทำงานโดยการล็อกทรัพยากรเมื่อ goroutine กำลังรอ และปลดล็อกทรัพยากรเมื่อเงื่อนไขเป็นจริง

ประโยชน์

ช่วยให้ goroutines สามารถรอเหตุการณ์บางอย่างได้อย่างมีประสิทธิภาพ
ปรับปรุงประสิทธิภาพโดยหลีกเลี่ยงการวนซ้ำตรวจสอบเงื่อนไขอย่างต่อเนื่อง

Note

Cond กับ Mutex ต่างก็เป็นตัวแปรแบบ sync.Locker ทั้งคู่ แต่ทำหน้าที่ต่างกัน

Mutex ทำหน้าที่ป้องกันไม่ให้ goroutine อื่นเข้าถึงทรัพยากรร่วมกันในเวลาเดียวกัน

ขณะที่ Cond ทำหน้าที่เป็นสัญญาณระหว่าง goroutine ต่างๆ

Cond ทำงานโดยอาศัย mutex เป็นตัวล็อกทรัพยากรร่วมกัน เมื่อ goroutine ต้องการที่จะส่งสัญญาณให้ goroutine อื่น จะต้องทำการ Lock mutex ก่อน จากนั้นจึงเรียกใช้ฟังก์ชัน Signal() หรือ Broadcast() เมื่อ goroutine อื่นทำการปลดล็อค mutex ก็จะสามารถตรวจจับสัญญาณได้

ดังนั้น Cond จึงจำเป็นต้องใช้งานคู่กับ Mutex เพื่อให้สามารถทำงานได้อย่างมีประสิทธิภาพ Mutex จะทำหน้าที่ป้องกันไม่ให้ goroutine อื่นเข้ามารบกวนการทำงานของ goroutine ที่ส่งสัญญาณ ในขณะที่ Cond จะทำหน้าที่ส่งสัญญาณให้ goroutine อื่นรับรู้ถึงเหตุการณ์ที่ต้องการ

# Mutex-guarded condition variable
mutex-guarded condition variable เป็นโครงสร้างข้อมูลแบบ mutex-guarded ที่ช่วย goroutines สามารถรอเงื่อนไขบางอย่างให้เป็นจริง Mutex-guarded condition variable ประกอบด้วยสองส่วนหลัก:

Mutex = ช่วยให้ goroutines สามารถเข้าถึงทรัพยากรร่วมกันได้อย่างปลอดภัย
Condition variable = ช่วยให้ goroutines สามารถรอเงื่อนไขบางอย่างให้เป็นจริง
การทำงานพื้นฐานของ mutex-guarded condition variable เป็นไปตามขั้นตอนต่อไปนี้:

Goroutine ที่ต้องการรอเงื่อนไขบางอย่างจะล็อก mutex ที่เกี่ยวข้อง
Goroutine จะเรียกฟังก์ชัน wait() ของ condition variable ซึ่งจะปลดล็อก mutex และบล็อก goroutine นั้น
เมื่อเงื่อนไขเป็นจริง goroutine อื่น ๆ ใด ๆ ก็สามารถเรียกฟังก์ชัน signal() หรือ broadcast() ของ condition variable ได้
ฟังก์ชัน signal() จะปลุก goroutine หนึ่งตัวที่กำลังรอใน condition variable
ฟังก์ชัน broadcast() จะปลุก goroutine ทั้งหมดที่กำลังรอใน condition variable
เมื่อ goroutine ที่รอเงื่อนไขบางอย่างถูกปลุกขึ้นมา มันจะปลดล็อก mutex และดำเนินการต่อไป

mutex-guarded condition variable มักใช้เพื่อประสานงานระหว่าง goroutines เช่น การรอให้เหตุการณ์บางอย่างเกิดขึ้น การรอให้ goroutine อื่นทำงานเสร็จสิ้น หรือการป้องกัน race conditions

# ตัวอย่างการใช้งาน mutex-guarded condition variable ได้แก่:

การรอข้อความจาก Network = Goroutine ที่ต้องการรับข้อความจากเครือข่ายสามารถรอใน condition variable จนกระทั่งมีข้อความมาถึง
การรอให้ goroutine อื่นทำงานเสร็จสิ้น = Goroutine ที่ต้องการรอให้ goroutine อื่นทำงานเสร็จสิ้นสามารถรอใน condition variable จนกระทั่ง goroutine อื่นนั้นเสร็จสิ้นการทำงาน
การป้องกัน race conditions = Goroutine ที่ต้องการป้องกัน race conditions สามารถรอใน condition variable จนกระทั่งทรัพยากรที่เกี่ยวข้องพร้อมใช้งาน
เพิ่มเติมปัญหา Deadlock
Deadlock สำหรับ goroutine หมายถึงสถานการณ์ที่ goroutine จะอยู่สถานะ block "ตลอดกาล" โดย

ทำการรอ Resource อื่นมาปล่อย block
แต่ไม่มี Resource ตัวไหนมาทำการปล่อยให้
สถานการณ์นี้มักเกิดจากการจัดการ Concurrency ไว้ไม่ถูกต้องจากตัวของ channel, mutexes หรือ waitgroup โดยสถานที่มักจะเกิด deadlock ขึ้นได้ประจำจะมีดังนี้

# Mutual Locking (Mutex Deadlock)
Gouroutine ตั้งแต่สองตัวขึ้นไปต่างก็ถือ mutex และรอรับ mutex ที่อีกตัวถืออยู่ (อยู่ wait state ทั้งคู่) สิ่งนี้จะสร้างวงจรการขึ้นต่อกันที่ไม่สามารถแก้ไขได้ ซึ่งนำไปสู่ Deadlock

# Channel deadlock
สิ่งนี้เกิดขึ้นเมื่อ goroutine กำลังรอส่งหรือรับข้อมูลใน channel แต่ไม่มี goroutine อื่นที่พร้อมให้ดำเนินการตรงกันข้าม (receive / send ข้อมูลใน channel) ตัวอย่างเช่น

Deadlock อาจเกิดขึ้นได้หาก goroutine ทั้งหมดกำลังรอรับจากช่อง แต่ไม่มี goroutine ใดถูกส่งไป (หรือกลับกัน มีคนส่งไปแต่ไม่มีคนรับ)
Improper Use of WaitGroups
Deadlock อาจเกิดขึ้นได้หากใช้ sync.WaitGroup ไม่ถูกต้อง ตัวอย่างเช่น

รอบน WaitGroup โดยไม่ได้รับประกันว่าการดำเนินการเพิ่มทั้งหมดจะเสร็จสิ้นก่อนการรอ
หากจำนวน Done ไม่ตรงกับจำนวนการ Add ที่เพิ่มไป = เข้าสู่ภาวะ Deadlock ได้ เนื่องจากเป็นการรอไม่มีที่สิ้นสุด
Nested Locks
Deadlock ยังอาจเกิดขึ้นได้เมื่อคุณมีการล็อกแบบซ้อนกัน (การรับ mutexes หลายตัว) โดยไม่มีลำดับการล็อกที่สอดคล้องกัน ซึ่งนำไปสู่เงื่อนไขการรอแบบวงกลม (circular wait conditions)

Deadlock อาจเกิดขึ้นเล็กน้อยและมักจะ debug ได้ยาก เนื่องจากอาจเกิดขึ้นภายใต้เงื่อนไขเฉพาะหรือในช่วงเวลาที่เจาะจงเท่านั้น

เพื่อหลีกเลี่ยง Deadlock สิ่งสำคัญคือต้องออกแบบรูปแบบการ interaction goroutine อย่างระมัดระวัง หลีกเลี่ยงการ lock goroutine หลายรายการ (ใช้เท่าที่จำเป็น) และคำนึงถึงวิธีที่ goroutine สื่อสารและ synchronize ระหว่างกันด้วย



# =================  Pattern อื่นๆ
Distributed systems: Pattern สำหรับการกระจายข้อมูลผ่าน goroutines
Pipeline: Pattern นี้เชื่อมต่อ goroutine หลายตัวเข้าด้วยกัน โดยผลลัพธ์จาก goroutine หนึ่งเป็นอินพุตสำหรับ goroutine ถัดไป เหมาะกับงานที่เป็นลำดับ เช่น ประมวลผลข้อมูลเป็นขั้นตอน ทำได้โดยใช้ channel เชื่อมต่อ goroutine ต่างๆ
Worker pool: Pattern นี้ใช้ pool ของ goroutines ที่ทำงานเสร็จแล้วรอรับงานใหม่แทนการสร้าง goroutine ใหม่ตลอดเวลา เหมาะกับงานจำนวนมากที่ไม่ขึ้นต่อกัน เช่น ประมวลผลรูปภาพ ทำได้โดยใช้ queue หรือ channel เพื่อเก็บงาน และใช้ goroutine ใน pool รับงานจาก queue/channel ไปประมวลผล
Rate limiting: Pattern นี้ควบคุมจำนวนการทำงานของ goroutine ต่อช่วงเวลา เหมาะกับป้องกัน server โอเวอร์โหลด ทำได้โดยใช้ package sync/atomic หรือ channel ร่วมกับ timer
# คำแนะนำในการใช้ goroutine
Go routine ของ Go เป็นเครื่องมือที่มีประสิทธิภาพในการทำให้โปรแกรมทำงานได้เร็วขึ้นโดยการใช้ทรัพยากร CPU ร่วมกัน โดยทั่วไปแล้ว เราควรใช้ go routine ใน use case ต่อไปนี้

งานที่ต้องใช้เวลานาน เช่น การประมวลผลข้อมูลขนาดใหญ่ การดาวน์โหลดไฟล์ขนาดใหญ่ หรือการวิเคราะห์ข้อมูล
งานที่ต้องทำงานซ้ำๆ เช่น การวนลูปเพื่อประมวลผลข้อมูลจำนวนมาก การอ่านข้อมูลจากอุปกรณ์ หรือการเชื่อมต่อกับ API
งานที่ต้องทำงานพร้อมกัน เช่น การประมวลผลคำขอจากผู้ใช้หลายราย การดาวน์โหลดไฟล์หลายไฟล์พร้อมกัน หรือการวิเคราะห์ข้อมูลหลายชุดพร้อมกัน
# ตัวอย่างของ use case ที่ควรใช้ go routine ได้แก่

โปรแกรมที่ประมวลผลข้อมูลขนาดใหญ่ เช่น โปรแกรมประมวลผลภาพหรือเสียง โปรแกรมประมวลผลข้อมูลทางการแพทย์หรือทางการเงิน
โปรแกรมที่ดาวน์โหลดไฟล์ขนาดใหญ่ เช่น โปรแกรมดาวน์โหลดเพลงหรือภาพยนตร์ โปรแกรมดาวน์โหลดไฟล์จากอินเทอร์เน็ต
โปรแกรมที่วิเคราะห์ข้อมูลขนาดใหญ่ เช่น โปรแกรมวิเคราะห์ข้อมูลพฤติกรรมผู้บริโภค โปรแกรมวิเคราะห์ข้อมูลทางธุรกิจ
โปรแกรมที่ให้บริการผู้ใช้จำนวนมาก เช่น โปรแกรมเว็บเซิร์ฟเวอร์ โปรแกรมแชทบอท โปรแกรมเกม
อย่างไรก็ตาม เราควรระมัดระวังในการเลือกใช้ go routine เนื่องจาก go routine แต่ละตัวจะใช้ทรัพยากร CPU อยู่ตลอดเวลา ดังนั้นหากเราใช้ go routine มากเกินไปก็อาจทำให้โปรแกรมทำงานช้าลงหรือทำให้เครื่องร้อนเกินไปได้

# คำแนะนำในการใช้ go routine อย่างมีประสิทธิภาพ ได้แก่

กำหนดจำนวน go routine ให้เหมาะสม โดยทั่วไปแล้ว เราควรใช้ go routine ไม่เกินจำนวน CPU ของเครื่อง หากเราใช้ go routine มากเกินไปก็อาจทำให้โปรแกรมทำงานช้าลงหรือทำให้เครื่องร้อนเกินไปได้
ใช้ mutex หรือวิธีอื่นๆ เพื่อป้องกัน race condition Race condition คือ ปัญหาที่อาจเกิดขึ้นเมื่อหลาย goroutine พยายามเข้าถึงและแก้ไขทรัพยากรหรือข้อมูลร่วมกันในเวลาเดียวกัน การใช้ mutex หรือวิธีอื่นๆ จะช่วยป้องกัน race condition และทำให้โปรแกรมทำงานได้อย่างถูกต้อง
ตรวจสอบสถานะ go routine อย่างสม่ำเสมอ หาก go routine ใดๆ ทำงานผิดปกติหรือค้างก็อาจทำให้โปรแกรมทำงานผิดพลาดได้ เราควรตรวจสอบสถานะ go routine อย่างสม่ำเสมอเพื่อหาปัญหาที่อาจเกิดขึ้น




